---
layout: post
title:  python实现服务器文本读写总结 
date:   2018-12-14 19:44:00 
categories: Blog 
tag: Myblog
---

* content
{:toc}

为什么选择Python
===================
提到服务器的操作，大家首先想到的应该是“Shell”,作为一个专门操作服务器的语言，应该是最合适不过了。首先想到的也是这个语言，后来还专门在自己的虚拟机上实现了一番，结果最后应用到服务器上的时候，并不是自己想要的结果。

这么简单的需求，一个命令就可以搞定啊？
===================
确实，我用sed写了一条语句，也能实现相同的功能，而且立杆见影。然而应用到服务器的时候，意想不到的结果发生了，出bug了，原因是对该文件夹没有读写权限，而sed需要在文件夹中创建一个临时文件。所以，行不通。

代码很少，还搞了很久？
===================
确实，总共就两个小脚本，一个23行代码，一个11行代码，大部分内容还不是自己敲的，怎么还搞了两个下午？主要还是里面有坑，接下来细数一下路过的坑。
首先python，确实好用，用它进行文件的读写，再合适不过了。然后它又可以直接在服务器运行，如果需要部署其他软件的话，对不起，没有权限，毕竟被称作脚本语言，还是有它自身的优势的。然而坑就埋在这里，直接用确实还是有问题，这个问题也是老生常谈了，那就是Python版本问题。服务器默认的版本都是2.7，可以说是一代经典版本，然而经典也不是不能超越的，迭代后的版本确实比以前好用，也没这么多事儿。
最直接的问题就是代码编码问题，老版本必须得指明编码格式，不然，运行不了。
因为代码中有控制台的交互，也就是最传统的输入输出，python2.7画蛇添足的多了一个raw_input，还要留意一下这个。

难道只是因为有坑？
===================
当然不是啦，有坑也不至于这么久啊，关键还是不熟练。习惯了复制粘贴，没有示例的代码，完全不知道从而下手。其实这也可以理解，最难以接受的是，写了无数遍的内容，到时候还是要百度，完全没有记住。
首先是递归函数，当然这个也不常用，但是已经完全不知道怎么实现的了，又百度了一下，才想起递归是在函数的协助下实现的，就是在函数里又嵌套自己。如果记得这句话，估计也就能写出来了。
如果递归不会，还可以理解，但是函数都不会写了能说明了什么？说明连最最基础的不会。当然还有一部分原因是和java的代码混淆了，可见还是熟练掌握一门比较靠谱。问题出现在了参数的传递，写完函数以后，发现函数里的参数到下面运行不下去了，说是没有定义。其实呢，是参数需要返回一下，也就是 “retuan 参数”。

最后的bug
===================
本以为胜利在即，逻辑通顺，一开始测试也没问题，结果测试测试着就出了这个bug：
UnboundLocalError： local variable 'xxx' referenced before assignment
说明自己的代码还是经不起推敲，其实这么说都对不住推敲这个词儿，总共也没几行代码，逻辑也简单的不行，怎么还有意想不到的bug呢？
原因还是自己对这个没有系统的认识，当然这也是其中的一个坑，就是全局变量的坑。熟悉java的人对全局变量再熟悉不过，然而对于python，因为不用声明变量，往往对这个容易忽视，在函数里面，因为程序运行等其他一系列说不清楚还请看链接[CSDN](https://blog.csdn.net/onlyanyz/article/details/45009697)的原因导致的。当然这主要还说明了自己对Python还不是很熟，要走的路还很远。

信息录入代码(python3.1)：

```python
import os
print("请输入id")
id = str(input('')).strip()
print("请输入slot")
def Slot():
    slot = str(input('')).strip()
    if(len(slot)!=32):
        print("slot位数不对，请重新输入")
        Slot()
    else:
        a=id+"@*@"+slot+"@0.5"+"\n"
        print(a)
    return a
c=Slot()
print("确认正确后请输入0后回车（enter)，不正确请按其他任意键")
if(input().strip()=="0"):
    #os.system("echo $a >> test.py" )
    f=open('sampling-log.properties','a')
    f.write(c)
    print("成功写入文件")
else:
    exit()
    print("成功退出，请重新运行该程序")
```

注释录入信息代码(python2.7)：

```python
# -*- coding:utf-
lines = []
with open('sampling-log.properties', 'r') as f_in:
    for line in f_in:
        if(line[0]!='#') and (line[0]!='\n'):
            line = '#'+line[0:-1]+'\n'
        else:
            line = line
        lines.append(line)
with open('sampling-log.properties', 'w') as f_out:
    f_out.writelines(lines)
```

